#!/bin/bash

# >> GLOBALES VARIABLES

SUCCESS=0
FAILURE=1

HELP="Usage: $0 [OPTION]... [COMMAND] [REQUEST]
OPTION:
  -h		display usage
  -f FILE	json database file
  -j		json formated output for select command"

# > JSON BDD Path

if [ -f ".bdshrc" ]; then
        BDD_FILE="$(cat .bdshrc)"
fi

if [ "${BDSH_File}" != "" ]; then
        BDD_FILE="${BDSH_File}"
fi

FILE=""
DB_VALUE=""
TABLE_VALUE=()

# >> Functions

function print_error {
    printf "%s\n" "$1" 1>&2
    return $FAILURE
}

function is_readable {
    if [ -r "$BDD_FILE" ]; then
        return $SUCCESS
    fi
    return $FAILURE
}

function is_writable {
    if [ -w "$BDD_FILE" ]; then
            return $SUCCESS
    fi
    return $FAILURE
}

function database_in_file {
    is_readable "$BDD_FILE"
    if [ $? == $FAILURE ]; then
        print_error "Error: '$BDD_FILE' unreadable."
        return $FAILURE
    fi

    grep -nwF "$1" <"$BDD_FILE" >/dev/null
    if [ $? == $FAILURE ]; then
        print_error "Error: '$DATABASE' not in '$BDD_FILE'"
        return $FAILURE
    fi
    return $SUCCESS
}

function get_value_from_table {
    res="$(grep -wF "$1" <<< $DB_VALUE | cut -d ':' -f2 | cat )"
    TABLE_VALUE=()
    nb_lines=0
    for line in $res; do
            tmp=$line
            line=${line#" "}
            line=${line#"\""}
            line=${line%","}
            line=${line%"\""}
            if [[ ! $tmp =~ ^\".*$ ]]; then
                    let nb_lines--
                    TABLE_VALUE[$nb_lines]=${TABLE_VALUE[$nb_lines]%"\\\\"}
                    line=$(printf "%s%s" "${TABLE_VALUE[$nb_lines]}" "--$line")
                    TABLE_VALUE[$nb_lines]=$line'\\'
            else
                    TABLE_VALUE+=($line'\\')
            fi
        let nb_lines++
    done
}

function select_db {
    DATABASE="data_$1"
    find_db_value "$DATABASE"
    tables="$(tr ',' '\n' <<< $2)"
    tables_arr=()
    max_len=()
    i=0
    lines=()
    first_line=""
    for table in $tables; do
        get_value_from_table "$table"
        dict_value[$i]=${TABLE_VALUE[*]}
        tables_arr[$i]=$table
        lines[$i]=""
        let i++
    done

    f=0
    for index in "${!dict_value[@]}"; do
        max_len[$index]=${#tables_arr[$index]}
        for value in ${dict_value[$index]}; do
            if [ "$(expr ${#value} - 2)" -gt ${max_len[$index]} ]; then
                max_len[$index]=$(expr ${#value} - 2)
            fi
            let f++
        done
        if [ $index == 0 ]; then
            first_line+="$(printf "%-${max_len[$index]}s  |" "${tables_arr[$index]}")"
        elif [ $index == "$(expr $i - 1)" ]; then
            first_line+="$(printf "  %-${max_len[$index]}s" "${tables_arr[$index]}")"
        else
            first_line+="$(printf "  %-${max_len[$index]}s  |" "${tables_arr[$index]}")"
        fi
        f=0
        for value in ${dict_value[$index]}; do
            value=${value%"\\\\"}
            if [ $index == 0 ]; then
                lines[$f]+="$(printf "%-${max_len[$index]}s  |" "$value")"
            elif [ $index == "$(expr $i - 1)" ]; then
                lines[$f]+="$(printf "  %-${max_len[$index]}s" "$value")"
            else
                lines[$f]+="$(printf "  %-${max_len[$index]}s  |" "$value")"
            fi
            let f++
        done
    done

    printf "%s\n" "$first_line"
    for ((i=0 ; i < ${#lines[0]} ; i++)); do
        printf "-"
    done
    printf "\n"
    if [ "$3" == "order" ]; then
            IFS=$'\n' lines=($(sort <<< "${lines[*]}"))
            unset IFS
    fi
    f=0
    for line in "${lines[@]}"; do
        line=$(sed 's/--/ /g' <<< $line)
        printf "%s\n" "$line"
    done
}

function find_db_value {
    START="$(grep -nwF "$DATABASE" < $BDD_FILE | cut -d ':' -f1)"
    LEN="$(expr "$(wc -l < $BDD_FILE | cut -d ' ' -f1)" - $START)"
    END="$(expr "$(tail -n $LEN < $BDD_FILE | grep -nwF "]" | cut -d ':' -f1 | head -n 1)" - 1)"

    DB_VALUE="$(tail -n $LEN < $BDD_FILE | head -n $END)"
}

function describe_db {
    DATABASE="desc_$1"

    database_in_file "$DATABASE"
    if [ $? == $FAILURE ]; then
        return $FAILURE
    fi

    find_db_value "$DATABASE"
    for line in $DB_VALUE; do
        printf "%s\n" "$(echo $line | tr -d "\t, \"")"
    done
    return $SUCCESS
}

function change_bdd_file {
    if [ -e "$BDD_FILE" ]; then
        if [ -f "$BDD_FILE" ]; then
            FILE="$(cat $BDD_FILE)"
            return $SUCCESS
        else
            print_error "Error: '$BDD_FILE' isn't a regular file."
        fi
    else
        print_error "Error: '$BDD_FILE' doesn't exist."
    fi
    return $FAILURE
}

function main {
    while [ $# != 0 ]; do
        case "$1" in
            "-h") printf "%s\n" "$HELP"
                  return $SUCCESS;;
            "-f") shift
                  BDD_FILE="$1"
                  change_bdd_file "$1";;
            "-j") ;;
            "select") shift
                      select_db "$@"
                      shift
                      if [ "$2" == "order" ]; then
                              shift
                      fi;;
            "describe") shift
                        describe_db "$@";;
            "insert") shift;;
            "create") shift;;
            *) print_error "Error: '$1': Bad argument"
                return $FAILURE;;
        esac
        if [ $? == $FAILURE ]; then
            return $FAILURE
        fi
        shift
    done

    return $SUCCESS
}

# >> Initialization

if [ $# == 0 ]; then
    print_error "$HELP"
else
    main "$@"
fi
